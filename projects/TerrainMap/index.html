<html>
<head>
<!--
Scott Wu
47be1f67c35cb3bd7fdaae284c21c69a
-->
<title>Scott Wu ~ Terrain Map</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8;" />
<script type="text/javascript" src="/lib/three.min-57.js"></script>
<script type="text/javascript" src="/lib/webgl-utils.js"></script>
<style type="text/css">
body {
	background-color: #000000;
	background-position: left top;
	overflow: hidden;
	padding: 0px;
}

#wrap {
	width: 100%;
	height: 100%;
}

#instructions {
	position: absolute;
	top: 0px;
	z-index: 2;
	color: white;
}

#container {
	width: 100%;
	height: 100%;
}
</style>
<script type="text/javascript">
var ctx,renderer,keys,mouse;
var scene,textures,camera,sun,map;

function init() {
	keys = new Array(256);
	for (var i=0; i<keys.length; i++) keys[i] = false;
	mouse = [0,0,0,0,0];
	setEvents(document.body);
	
	ctx = document.getElementById("container");
	
	renderer = new THREE.WebGLRenderer();
	renderer.setSize(ctx.offsetWidth,ctx.offsetHeight);
	ctx.appendChild(renderer.domElement);
	
	textures = [ THREE.ImageUtils.loadTexture("lib/ground2048.jpg") ];
	textures[0].wrapS = THREE.RepeatWrapping;
	textures[0].wrapT = THREE.RepeatWrapping;
	
	scene = new THREE.Scene();
	camera = new THREE.PerspectiveCamera(60,ctx.offsetWidth/ctx.offsetHeight,0.1,400);
	terrain = new THREE.Mesh(generateTerrain(),new THREE.MeshPhongMaterial({color: 0xFFFFFF,specular: 0x000000,ambient: 0x000000,map: textures[0]}));
	
	sun = new THREE.DirectionalLight(0xFFFFFF,1);
	sun.position.set(0,1,1);
	
	scene.add(camera);
	scene.add(terrain);
	scene.add(sun);
	
	frame();
}

function generateTerrain() {
	var size = 64,uvsize = 4,startHeight = 32;
	var heights = new Array(size),written = new Array(size);
	var geo = new THREE.Geometry();
	for (var i=0; i<size; i++) {
		heights[i] = new Array(size);
		written[i] = new Array(size);
		for (var j=0; j<size; j++) {
			heights[i][j] = 0;
			written[i][j] = false;
		}
	}
	midpoint(heights,written,0,size-1,0,size-1,startHeight);
	var ind = 0,ci,cj,ni,nj;
	for (var i=0; i<size-1; i++) {
		for (var j=0; j<size-1; j++) {
			ci = 2*i-size+0.5; ni = ci + 2;
			cj = 2*j-size+0.5; nj = cj + 2;
			geo.vertices.push(new THREE.Vector3(ci, heights[i][j],		cj));
			geo.vertices.push(new THREE.Vector3(ci, heights[i][j+1],	nj));
			geo.vertices.push(new THREE.Vector3(ni, heights[i+1][j+1],	nj));
			geo.vertices.push(new THREE.Vector3(ni, heights[i+1][j],	cj));
			geo.faces.push(new THREE.Face4(ind++,ind++,ind++,ind++));
			geo.faceVertexUvs[0].push([
				new THREE.Vector2(ci/size*uvsize,cj/size*uvsize),
				new THREE.Vector2(ci/size*uvsize,nj/size*uvsize),
				new THREE.Vector2(ni/size*uvsize,nj/size*uvsize),
				new THREE.Vector2(ni/size*uvsize,cj/size*uvsize)
			]);
		}
	}
	geo.mergeVertices();
	geo.computeFaceNormals();
	geo.computeVertexNormals();
	camera.position.set(0,startHeight,0);
	return geo;
}

function midpoint(heights,written,sx,ex,sy,ey,range) {
	if (ex-sx<2 && ey-sy<2) return;
	var mx = ~~((ex+sx)/2);
	var my = ~~((ey+sy)/2);
	if (!written[mx][my]) heights[mx][my] = (heights[sx][sy] + heights[sx][ey] + heights[ex][sy] + heights[ex][ey])/4 + random(range);
	if (!written[mx][sy]) heights[mx][sy] = (heights[sx][sy] + heights[ex][sy])/2 + random(range);
	if (!written[mx][ey]) heights[mx][ey] = (heights[sx][ey] + heights[ex][ey])/2 + random(range);
	if (!written[sx][my]) heights[sx][my] = (heights[sx][sy] + heights[sx][ey])/2 + random(range);
	if (!written[ex][my]) heights[ex][my] = (heights[ex][sy] + heights[ex][ey])/2 + random(range);
	written[mx][my] = true;
	written[mx][sy] = true;
	written[mx][ey] = true;
	written[sx][my] = true;
	written[ex][my] = true;
	midpoint(heights,written,sx,mx,sy,my,range/2);
	midpoint(heights,written,sx,mx,my,ey,range/2);
	midpoint(heights,written,mx,ex,sy,my,range/2);
	midpoint(heights,written,mx,ex,my,ey,range/2);
}

function random(range) {
	return (Math.random()*2-1)*range;
}

function normal(part) {
	
}

function setEvents(element) {
	element.onkeydown = function(event) {
		keys[event.which] = true;
	};
	element.onkeyup = function(event) {
		keys[event.which] = false;
	};
	element.onmousemove = function(event) {
		mouse[0] = event.clientX - ctx.offsetLeft;
		mouse[1] = event.clientY - ctx.offsetTop;
	}
	element.onmousedown = function(event) {
		mouse[0] = event.clientX - ctx.offsetLeft;
		mouse[1] = event.clientY - ctx.offsetTop;
		mouse[2] = event.clientX - ctx.offsetLeft;
		mouse[3] = event.clientY - ctx.offsetTop;
		mouse[4] = 1;
		camx2 = camx;
		camy2 = camy;
	}
	element.onmouseup = function(event) {
		mouse[0] = event.clientX - ctx.offsetLeft;
		mouse[1] = event.clientY - ctx.offsetTop;
		mouse[4] = 0;
	}
	element.onfocus = function(event) {
		mouse[4] = 0;
	}
	element.onblur = function(event) {
		mouse[4] = 0;
	}
}

var camx = 0,camy = 0,camx2 = 0,camy2 = 0,sunrot = 0; // ud,lr
var dir = new THREE.Vector3(0,0,0);
function frame() {
	requestAnimFrame(frame);
	if (mouse[4]==1) {
		var shiftx = mouse[2]-mouse[0];
		var shifty = mouse[3]-mouse[1];
		camx = camx2 - shiftx/ctx.offsetWidth*4*Math.PI;
		camy = camy2 + shifty/ctx.offsetHeight*Math.PI;
	}
	var r = 0.4;
	dir = new THREE.Vector3(r*Math.cos(camx)*Math.cos(camy),r*Math.sin(camy),r*Math.sin(camx)*Math.cos(camy));
	var sidedir = new THREE.Vector3(r*Math.cos(camx-Math.PI/2)*Math.cos(camy),0,r*Math.sin(camx-Math.PI/2)*Math.cos(camy));
	
	if (keys[87]) {
		camera.position.x += dir.x;
		camera.position.y += dir.y;
		camera.position.z += dir.z;
	}
	if (keys[83]) {
		camera.position.x -= dir.x;
		camera.position.y -= dir.y;
		camera.position.z -= dir.z;
	}
	if (keys[65]) {
		camera.position.x += sidedir.x;
		camera.position.y += sidedir.y;
		camera.position.z += sidedir.z;
	}
	if (keys[68]) {
		camera.position.x -= sidedir.x;
		camera.position.y -= sidedir.y;
		camera.position.z -= sidedir.z;
	}
	if (keys[81]) {
		camera.position.y += r;
	}
	if (keys[90]) {
		camera.position.y -= r;
	}
	
	dir.x += camera.position.x;
	dir.y += camera.position.y;
	dir.z += camera.position.z;
	camera.lookAt(dir);
	
	sunrot += 0.01;
	sun.position.set(Math.cos(sunrot),1,Math.sin(sunrot));
	
	renderer.render(scene,camera);
}
</script>
</head>
<body onload="javascript: init(); void 0;">
<div id="wrap">
	<div id="instructions">Click and drag to move camera. Use W and S to move forward and backward, A and D to move left and right, Q and Z to move up and down.</div>
	<div id="container"></div>
</div>
</body>
</html>
